/// <reference types="node" />
/// <reference lib="esnext.asynciterable" />

import { Binary, Decimal128, Double, Int32, Long, ObjectId, Timestamp } from "bson";
import { EventEmitter } from "events";
import { Readable, Writable } from "stream";
import { checkServerIdentity } from "tls";

type FlattenIfArray<T> = T extends ReadonlyArray<infer R> ? R : T;
export type WithoutProjection<T> = T & { fields?: undefined; projection?: undefined };

export function connect(uri: string, options?: MongoClientOptions): Promise<MongoClient>;
export function connect(uri: string, callback: MongoCallback<MongoClient>): void;
export function connect(uri: string, options: MongoClientOptions, callback: MongoCallback<MongoClient>): void;

export { Binary, DBRef, Decimal128, Double, Int32, Long, MaxKey, MinKey, ObjectID, ObjectId, Timestamp } from "bson";

type NumericTypes = number | Decimal128 | Double | Int32 | Long;
export class MongoClient extends EventEmitter {
    constructor(uri: string, options?: MongoClientOptions);
    static connect(uri: string, callback: MongoCallback<MongoClient>): void;
    static connect(uri: string, options?: MongoClientOptions): Promise<MongoClient>;
    static connect(uri: string, options: MongoClientOptions, callback: MongoCallback<MongoClient>): void;
    connect(): Promise<MongoClient>;
    connect(callback: MongoCallback<MongoClient>): void;
    close(callback: MongoCallback<void>): void;
    close(force?: boolean): Promise<void>;
    close(force: boolean, callback: MongoCallback<void>): void;
    db(dbName?: string, options?: MongoClientCommonOption): Db;
    isConnected(options?: MongoClientCommonOption): boolean;
    startSession(options?: SessionOptions): ClientSession;
    watch<TSchema extends object = { _id: ObjectId }>(
        pipeline?: object[],
        options?: ChangeStreamOptions & { session?: ClientSession | undefined },
    ): ChangeStream<TSchema>;
    withSession(operation: (session: ClientSession) => Promise<any>): Promise<void>;
    withSession(options: SessionOptions, operation: (session: ClientSession) => Promise<any>): Promise<void>;

    readPreference: ReadPreference;
    writeConcern: WriteConcern;
}

export type ClientSessionId = unknown;
export interface ClientSession extends EventEmitter {
    id: ClientSessionId;
    abortTransaction(): Promise<void>;
    abortTransaction(callback?: MongoCallback<void>): void;
    advanceOperationTime(operationTime: Timestamp): void;
    commitTransaction(): Promise<void>;
    commitTransaction(callback: MongoCallback<void>): void;
    endSession(callback?: MongoCallback<void>): void;
    endSession(options: Object, callback: MongoCallback<void>): void;
    endSession(options?: Object): Promise<void>;
    equals(session: ClientSession): boolean;
    incrementTransactionNumber(): void;
    inTransaction(): boolean;
    startTransaction(options?: TransactionOptions): void;
    withTransaction(fn: WithTransactionCallback, options?: TransactionOptions): Promise<any>;
}
type ReadConcernLevel = "local" | "available" | "majority" | "linearizable" | "snapshot";
export interface ReadConcern {
    level: ReadConcernLevel;
}

interface WriteConcern {
    w?: number | "majority" | string | undefined;
    j?: boolean | undefined;
    wtimeout?: number | undefined;
}
export interface SessionOptions {
    causalConsistency?: boolean | undefined;
    defaultTransactionOptions?: TransactionOptions | undefined;
}

export interface TransactionOptions {
    readConcern?: ReadConcern | undefined;
    writeConcern?: WriteConcern | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
}

export interface MongoClientCommonOption {
    noListener?: boolean | undefined;
    returnNonCachedInstance?: boolean | undefined;
}

export interface MongoCallback<T> {
    (error: MongoError, result: T): void;
}
export type WithTransactionCallback = (session: ClientSession) => Promise<void>;

export class MongoError extends Error {
    constructor(message: string | Error | object);
    static create(options: string | Error | object): MongoError;
    hasErrorLabel(label: string): boolean;
    readonly errorLabels: string[];
    code?: number | string | undefined;
    errmsg?: string | undefined;
    name: string;
}

export class MongoNetworkError extends MongoError {}

export class MongoParseError extends MongoError {}

export class MongoTimeoutError extends MongoError {
    reason?: string | object | undefined;
}

export class MongoServerSelectionError extends MongoTimeoutError {}

export class MongoWriteConcernError extends MongoError {
    result?: object | undefined;
}
export class BulkWriteError extends MongoError {}
export { BulkWriteError as MongoBulkWriteError };

export interface MongoClientOptions
    extends DbCreateOptions,
        ServerOptions,
        MongosOptions,
        ReplSetOptions,
        SocketOptions,
        SSLOptions,
        TLSOptions,
        HighAvailabilityOptions,
        UnifiedTopologyOptions {
    loggerLevel?: string | undefined;
    logger?: object | log | undefined;
    validateOptions?: object | boolean | undefined;
    appname?: string | undefined;
    auth?: {
        user: string;
        password: string;
    } | undefined;
    useNewUrlParser?: boolean | undefined;
    numberOfRetries?: number | undefined;
    authMechanism?:
        | "DEFAULT"
        | "GSSAPI"
        | "PLAIN"
        | "MONGODB-X509"
        | "MONGODB-CR"
        | "MONGODB-AWS"
        | "SCRAM-SHA-1"
        | "SCRAM-SHA-256"
        | string | undefined;
    compression?: {
        compressors?: Array<"snappy" | "zlib"> | undefined;
    } | undefined;
    directConnection?: boolean | undefined;
    autoEncryption?: AutoEncryptionOptions | undefined;
}
export interface AutoEncryptionExtraOptions {
    mongocryptdURI?: string | undefined;
    mongocryptdBypassSpawn?: boolean | undefined;
    mongocryptdSpawnPath?: string | undefined;
    mongocryptdSpawnArgs?: string[] | undefined;
}
export interface KMSProviders {
    aws?: {
        accessKeyId?: string | undefined;
        secretAccessKey?: string | undefined;
    } | undefined;
    gcp?: {
        email?: string | undefined;
        privateKey?: string | Buffer | undefined;
        endpoint?: string | undefined;
    } | undefined;
    local?: {
        key?: Buffer | undefined;
    } | undefined;
}
export interface AutoEncryptionOptions {
    keyVaultClient?: MongoClient | undefined;
    keyVaultNamespace?: string | undefined;
    kmsProviders?: KMSProviders | undefined;
    schemaMap?: object | undefined;
    bypassAutoEncryption?: boolean | undefined;
    extraOptions?: AutoEncryptionExtraOptions | undefined;
}

export interface SSLOptions {
    ciphers?: string | undefined;
    ecdhCurve?: string | undefined;
    poolSize?: number | undefined;
    minSize?: number | undefined;
    ssl?: boolean | undefined;
    sslValidate?: boolean | undefined;
    checkServerIdentity?: boolean | typeof checkServerIdentity | undefined;
    sslCA?: ReadonlyArray<Buffer | string> | undefined;
    sslCRL?: ReadonlyArray<Buffer | string> | undefined;
    sslCert?: Buffer | string | undefined;
    sslKey?: Buffer | string | undefined;
    sslPass?: Buffer | string | undefined;
    servername?: string | undefined;
}

export interface TLSOptions {
    tls?: boolean | undefined;
    tlsInsecure?: boolean | undefined;
    tlsCAFile?: string | undefined;
    tlsCertificateKeyFile?: string | undefined;
    tlsCertificateKeyFilePassword?: string | undefined;
    tlsAllowInvalidCertificates?: boolean | undefined;
    tlsAllowInvalidHostnames?: boolean | undefined;
}

export interface HighAvailabilityOptions {
    ha?: boolean | undefined;
    haInterval?: number | undefined;
    domainsEnabled?: boolean | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    readPreferenceTags?: ReadPreferenceTags | undefined;
}

export type ReadPreferenceTags = ReadonlyArray<Record<string, string>>;
export type ReadPreferenceMode = "primary" | "primaryPreferred" | "secondary" | "secondaryPreferred" | "nearest";
export type ReadPreferenceOrMode = ReadPreference | ReadPreferenceMode;
export type ReadPreferenceOptions = {
    hedge?: {
        enabled?: boolean | undefined;
    } | undefined;
    maxStalenessSeconds?: number | undefined;
};
export class ReadPreference {
    constructor(mode: ReadPreferenceMode, tags: object, options?: ReadPreferenceOptions);
    mode: ReadPreferenceMode;
    tags: ReadPreferenceTags;
    static PRIMARY: "primary";
    static PRIMARY_PREFERRED: "primaryPreferred";
    static SECONDARY: "secondary";
    static SECONDARY_PREFERRED: "secondaryPreferred";
    static NEAREST: "nearest";
    isValid(mode: ReadPreferenceMode | string): boolean;
    static isValid(mode: string): boolean;
    slaveOk(): boolean;
    equals(readPreference: ReadPreference): boolean;
}

export interface DbCreateOptions extends CommonOptions {
    authSource?: string | undefined;
    forceServerObjectId?: boolean | undefined;
    native_parser?: boolean | undefined;
    serializeFunctions?: boolean | undefined;
    ignoreUndefined?: boolean | undefined;
    raw?: boolean | undefined;
    promoteLongs?: boolean | undefined;
    promoteBuffers?: boolean | undefined;
    promoteValues?: boolean | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    pkFactory?: object | undefined;
    promiseLibrary?: PromiseConstructor | undefined;
    readConcern?: ReadConcern | string | undefined;
    bufferMaxEntries?: number | undefined;
}

export interface UnifiedTopologyOptions {
    useUnifiedTopology?: boolean | undefined;
    localThresholdMS?: number | undefined;
    serverSelectionTimeoutMS?: number | undefined;
    heartbeatFrequencyMS?: number | undefined;
    maxPoolSize?: number | undefined;
    minPoolSize?: number | undefined;
    maxIdleTimeMS?: number | undefined;
    waitQueueTimeoutMS?: number | undefined;
}

export interface SocketOptions {
    autoReconnect?: boolean | undefined;
    noDelay?: boolean | undefined;
    keepAlive?: boolean | undefined;
    keepAliveInitialDelay?: number | undefined;
    connectTimeoutMS?: number | undefined;
    family?: 4 | 6 | null | undefined;
    socketTimeoutMS?: number | undefined;
}

export interface ServerOptions extends SSLOptions {
    reconnectTries?: number | undefined;
    reconnectInterval?: number | undefined;
    monitoring?: boolean | undefined;
    monitorCommands?: boolean | undefined;
    socketOptions?: SocketOptions | undefined;
    haInterval?: number | undefined;
    domainsEnabled?: boolean | undefined;
    fsync?: boolean | undefined;
}
export interface MongosOptions extends SSLOptions, HighAvailabilityOptions {
    acceptableLatencyMS?: number | undefined;
    socketOptions?: SocketOptions | undefined;
}

export interface ReplSetOptions extends SSLOptions, HighAvailabilityOptions {
    maxStalenessSeconds?: number | undefined;
    replicaSet?: string | undefined;
    secondaryAcceptableLatencyMS?: number | undefined;
    connectWithNoPrimary?: boolean | undefined;
    socketOptions?: SocketOptions | undefined;
}

export type ProfilingLevel = "off" | "slow_only" | "all";

export class Db extends EventEmitter {
    constructor(databaseName: string, serverConfig: Server | ReplSet | Mongos, options?: DbCreateOptions);

    serverConfig: Server | ReplSet | Mongos;
    bufferMaxEntries: number;
    databaseName: string;
    options: any;
    native_parser: boolean;
    slaveOk: boolean;
    writeConcern: WriteConcern;

    addUser(username: string, password: string, callback: MongoCallback<any>): void;
    addUser(username: string, password: string, options?: DbAddUserOptions): Promise<any>;
    addUser(username: string, password: string, options: DbAddUserOptions, callback: MongoCallback<any>): void;
    admin(): Admin;
    collection<TSchema = DefaultSchema>(
        name: string,
        callback?: MongoCallback<Collection<TSchema>>,
    ): Collection<TSchema>;
    collection<TSchema = DefaultSchema>(
        name: string,
        options: DbCollectionOptions,
        callback?: MongoCallback<Collection<TSchema>>,
    ): Collection<TSchema>;
    collections(): Promise<Array<Collection<Default>>>;
    collections(callback: MongoCallback<Array<Collection<Default>>>): void;
    command(command: object, callback: MongoCallback<any>): void;
    command(
        command: object,
        options?: { readPreference?: ReadPreferenceOrMode | undefined; session?: ClientSession | undefined },
    ): Promise<any>;
    command(
        command: object,
        options: { readPreference: ReadPreferenceOrMode; session?: ClientSession | undefined },
        callback: MongoCallback<any>,
    ): void;
    createCollection<TSchema = DefaultSchema>(name: string, callback: MongoCallback<Collection<TSchema>>): void;
    createCollection<TSchema = DefaultSchema>(
        name: string,
        options?: CollectionCreateOptions,
    ): Promise<Collection<TSchema>>;
    createCollection<TSchema = DefaultSchema>(
        name: string,
        options: CollectionCreateOptions,
        callback: MongoCallback<Collection<TSchema>>,
    ): void;
    createIndex(name: string, fieldOrSpec: string | object, callback: MongoCallback<any>): void;
    createIndex(name: string, fieldOrSpec: string | object, options?: IndexOptions): Promise<any>;
    createIndex(name: string, fieldOrSpec: string | object, options: IndexOptions, callback: MongoCallback<any>): void;
    dropCollection(name: string): Promise<boolean>;
    dropCollection(name: string, callback: MongoCallback<boolean>): void;
    dropDatabase(): Promise<any>;
    dropDatabase(callback: MongoCallback<any>): void;
    executeDbAdminCommand(command: object, callback: MongoCallback<any>): void;
    executeDbAdminCommand(
        command: object,
        options?: { readPreference?: ReadPreferenceOrMode | undefined; session?: ClientSession | undefined },
    ): Promise<any>;
    executeDbAdminCommand(
        command: object,
        options: { readPreference?: ReadPreferenceOrMode | undefined; session?: ClientSession | undefined },
        callback: MongoCallback<any>,
    ): void;
    indexInformation(name: string, callback: MongoCallback<any>): void;
    indexInformation(name: string, options?: { full?: boolean | undefined; readPreference?: ReadPreferenceOrMode | undefined }): Promise<any>;
    indexInformation(
        name: string,
        options: { full?: boolean | undefined; readPreference?: ReadPreferenceOrMode | undefined },
        callback: MongoCallback<any>,
    ): void;
    listCollections(
        filter?: object,
        options?: {
            nameOnly?: boolean | undefined;
            batchSize?: number | undefined;
            readPreference?: ReadPreferenceOrMode | undefined;
            session?: ClientSession | undefined;
        },
    ): CommandCursor;
    profilingInfo(callback: MongoCallback<any>): void;
    profilingInfo(options?: { session?: ClientSession | undefined }): Promise<void>;
    profilingInfo(options: { session?: ClientSession | undefined }, callback: MongoCallback<void>): void;
    profilingLevel(callback: MongoCallback<ProfilingLevel>): void;
    profilingLevel(options?: { session?: ClientSession | undefined }): Promise<ProfilingLevel>;
    profilingLevel(options: { session?: ClientSession | undefined }, callback: MongoCallback<ProfilingLevel>): void;
    removeUser(username: string, callback: MongoCallback<any>): void;
    removeUser(username: string, options?: CommonOptions): Promise<any>;
    removeUser(username: string, options: CommonOptions, callback: MongoCallback<any>): void;
    renameCollection<TSchema = DefaultSchema>(
        fromCollection: string,
        toCollection: string,
        callback: MongoCallback<Collection<TSchema>>,
    ): void;
    renameCollection<TSchema = DefaultSchema>(
        fromCollection: string,
        toCollection: string,
        options?: { dropTarget?: boolean | undefined },
    ): Promise<Collection<TSchema>>;
    renameCollection<TSchema = DefaultSchema>(
        fromCollection: string,
        toCollection: string,
        options: { dropTarget?: boolean | undefined },
        callback: MongoCallback<Collection<TSchema>>,
    ): void;
    setProfilingLevel(level: ProfilingLevel, callback: MongoCallback<ProfilingLevel>): void;
    setProfilingLevel(level: ProfilingLevel, options?: { session?: ClientSession | undefined }): Promise<ProfilingLevel>;
    setProfilingLevel(
        level: ProfilingLevel,
        options: { session?: ClientSession | undefined },
        callback: MongoCallback<ProfilingLevel>,
    ): void;
    stats(callback: MongoCallback<any>): void;
    stats(options?: { scale?: number | undefined }): Promise<any>;
    stats(options: { scale?: number | undefined }, callback: MongoCallback<any>): void;
    unref(): void;
    watch<TSchema extends object = { _id: ObjectId }>(
        pipeline?: object[],
        options?: ChangeStreamOptions & { session?: ClientSession | undefined },
    ): ChangeStream<TSchema>;
}

export interface CommonOptions extends WriteConcern {
    session?: ClientSession | undefined;
    writeConcern?: WriteConcern | string | undefined;
}
export class Server extends EventEmitter {
    constructor(host: string, port: number, options?: ServerOptions);

    connections(): any[];
}
export class ReplSet extends EventEmitter {
    constructor(servers: Server[], options?: ReplSetOptions);

    connections(): any[];
}

export class Mongos extends EventEmitter {
    constructor(servers: Server[], options?: MongosOptions);

    connections(): any[];
}

export interface DbAddUserOptions extends CommonOptions {
    customData?: object | undefined;
    roles?: object[] | undefined;
}

export interface CollectionCreateOptions extends CommonOptions {
    raw?: boolean | undefined;
    pkFactory?: object | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    serializeFunctions?: boolean | undefined;
    strict?: boolean | undefined;
    capped?: boolean | undefined;
    autoIndexId?: boolean | undefined;
    size?: number | undefined;
    max?: number | undefined;
    flags?: number | undefined;
    storageEngine?: object | undefined;
    validator?: object | undefined;
    validationLevel?: "off" | "strict" | "moderate" | undefined;
    validationAction?: "error" | "warn" | undefined;
    indexOptionDefaults?: object | undefined;
    viewOn?: string | undefined;
    pipeline?: any[] | undefined;
    collation?: CollationDocument | undefined;
}

export interface DbCollectionOptions extends CommonOptions {
    raw?: boolean | undefined;
    pkFactory?: object | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    serializeFunctions?: boolean | undefined;
    strict?: boolean | undefined;
    readConcern?: ReadConcern | undefined;
}

export interface IndexOptions extends CommonOptions {
    unique?: boolean | undefined;
    sparse?: boolean | undefined;
    background?: boolean | undefined;
    dropDups?: boolean | undefined;
    min?: number | undefined;
    max?: number | undefined;
    v?: number | undefined;
    expireAfterSeconds?: number | undefined;
    name?: string | undefined;
    partialFilterExpression?: any;
    collation?: CollationDocument | undefined;
    default_language?: string | undefined;
}

export interface Admin {
    addUser(username: string, password: string, callback: MongoCallback<any>): void;
    addUser(username: string, password: string, options?: AddUserOptions): Promise<any>;
    addUser(username: string, password: string, options: AddUserOptions, callback: MongoCallback<any>): void;
    buildInfo(options?: { session?: ClientSession | undefined }): Promise<any>;
    buildInfo(options: { session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    buildInfo(callback: MongoCallback<any>): void;
    command(command: object, callback: MongoCallback<any>): void;
    command(command: object, options?: { readPreference?: ReadPreferenceOrMode | undefined; maxTimeMS?: number | undefined }): Promise<any>;
    command(
        command: object,
        options: { readPreference?: ReadPreferenceOrMode | undefined; maxTimeMS?: number | undefined },
        callback: MongoCallback<any>,
    ): void;
    listDatabases(options?: { nameOnly?: boolean | undefined; session?: ClientSession | undefined }): Promise<any>;
    listDatabases(options: { nameOnly?: boolean | undefined; session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    listDatabases(callback: MongoCallback<any>): void;
    ping(options?: { session?: ClientSession | undefined }): Promise<any>;
    ping(options: { session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    ping(callback: MongoCallback<any>): void;
    removeUser(username: string, callback: MongoCallback<any>): void;
    removeUser(username: string, options?: FSyncOptions): Promise<any>;
    removeUser(username: string, options: FSyncOptions, callback: MongoCallback<any>): void;
    replSetGetStatus(options?: { session?: ClientSession | undefined }): Promise<any>;
    replSetGetStatus(options: { session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    replSetGetStatus(callback: MongoCallback<any>): void;
    serverInfo(): Promise<any>;
    serverInfo(callback: MongoCallback<any>): void;
    serverStatus(options?: { session?: ClientSession | undefined }): Promise<any>;
    serverStatus(options: { session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    serverStatus(callback: MongoCallback<any>): void;
    validateCollection(collectionNme: string, callback: MongoCallback<any>): void;
    validateCollection(collectionNme: string, options?: object): Promise<any>;
    validateCollection(collectionNme: string, options: object, callback: MongoCallback<any>): void;
}

export interface AddUserOptions extends CommonOptions {
    fsync: boolean;
    customData?: object | undefined;
    roles?: object[] | undefined;
}

export interface FSyncOptions extends CommonOptions {
    fsync?: boolean | undefined;
}

type EnhancedOmit<T, K> = string | number extends keyof T
    ? T 
    : T extends any
    ? Pick<T, Exclude<keyof T, K>> 
    : never;

type ExtractIdType<TSchema> = TSchema extends { _id: infer U } 
        ? Exclude<U, {}>
        : unknown extends U
        ? ObjectId
        : U
    : ObjectId;

export type OptionalId<TSchema extends { _id?: any }> = ObjectId extends TSchema["_id"]
    ? 
      EnhancedOmit<TSchema, "_id"> & { _id?: ExtractIdType<TSchema> | undefined }
    : 
      WithId<TSchema>;

export type WithId<TSchema> = EnhancedOmit<TSchema, "_id"> & { _id: ExtractIdType<TSchema> };

export interface Collection<TSchema extends { [key: string]: any } = DefaultSchema> {
    collectionName: string;
    namespace: string;
    writeConcern: WriteConcern;
    readConcern: ReadConcern;
    hint: any;
    aggregate<T = TSchema>(callback: MongoCallback<AggregationCursor<T>>): AggregationCursor<T>;
    aggregate<T = TSchema>(pipeline: object[], callback: MongoCallback<AggregationCursor<T>>): AggregationCursor<T>;
    aggregate<T = TSchema>(
        pipeline?: object[],
        options?: CollectionAggregationOptions,
        callback?: MongoCallback<AggregationCursor<T>>,
    ): AggregationCursor<T>;
    bulkWrite(operations: Array<BulkWriteOperation<TSchema>>, callback: MongoCallback<BulkWriteOpResultObject>): void;
    bulkWrite(
        operations: Array<BulkWriteOperation<TSchema>>,
        options?: CollectionBulkWriteOptions,
    ): Promise<BulkWriteOpResultObject>;
    bulkWrite(
        operations: Array<BulkWriteOperation<TSchema>>,
        options: CollectionBulkWriteOptions,
        callback: MongoCallback<BulkWriteOpResultObject>,
    ): void;
    count(callback: MongoCallback<number>): void;
    count(query: FilterQuery<TSchema>, callback: MongoCallback<number>): void;
    count(query?: FilterQuery<TSchema>, options?: MongoCountPreferences): Promise<number>;
    count(query: FilterQuery<TSchema>, options: MongoCountPreferences, callback: MongoCallback<number>): void;
    countDocuments(callback: MongoCallback<number>): void;
    countDocuments(query: FilterQuery<TSchema>, callback: MongoCallback<number>): void;
    countDocuments(query?: FilterQuery<TSchema>, options?: MongoCountPreferences): Promise<number>;
    countDocuments(query: FilterQuery<TSchema>, options: MongoCountPreferences, callback: MongoCallback<number>): void;
    createIndex(fieldOrSpec: string | any, callback: MongoCallback<string>): void;
    createIndex(fieldOrSpec: string | any, options?: IndexOptions): Promise<string>;
    createIndex(fieldOrSpec: string | any, options: IndexOptions, callback: MongoCallback<string>): void;
    createIndexes(indexSpecs: IndexSpecification[], callback: MongoCallback<any>): void;
    createIndexes(indexSpecs: IndexSpecification[], options?: { session?: ClientSession | undefined }): Promise<any>;
    createIndexes(
        indexSpecs: IndexSpecification[],
        options: { session?: ClientSession | undefined },
        callback: MongoCallback<any>,
    ): void;
    deleteMany(filter: FilterQuery<TSchema>, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    deleteMany(filter: FilterQuery<TSchema>, options?: CommonOptions): Promise<DeleteWriteOpResultObject>;
    deleteMany(
        filter: FilterQuery<TSchema>,
        options: CommonOptions,
        callback: MongoCallback<DeleteWriteOpResultObject>,
    ): void;
    deleteOne(filter: FilterQuery<TSchema>, callback: MongoCallback<DeleteWriteOpResultObject>): void;
    deleteOne(
        filter: FilterQuery<TSchema>,
        options?: CommonOptions & { bypassDocumentValidation?: boolean | undefined },
    ): Promise<DeleteWriteOpResultObject>;
    deleteOne(
        filter: FilterQuery<TSchema>,
        options: CommonOptions & { bypassDocumentValidation?: boolean | undefined },
        callback: MongoCallback<DeleteWriteOpResultObject>,
    ): void;
    distinct<Key extends keyof WithId<TSchema>>(
        key: Key,
        callback: MongoCallback<Array<FlattenIfArray<WithId<Required<TSchema>>[Key]>>>,
    ): void;
    distinct<Key extends keyof WithId<TSchema>>(
        key: Key,
        query: FilterQuery<TSchema>,
        callback: MongoCallback<Array<FlattenIfArray<WithId<Required<TSchema>>[Key]>>>,
    ): void;
    distinct<Key extends keyof WithId<TSchema>>(
        key: Key,
        query?: FilterQuery<TSchema>,
        options?: MongoDistinctPreferences,
    ): Promise<Array<FlattenIfArray<WithId<Required<TSchema>>[Key]>>>;
    distinct<Key extends keyof WithId<TSchema>>(
        key: Key,
        query: FilterQuery<TSchema>,
        options: MongoDistinctPreferences,
        callback: MongoCallback<Array<FlattenIfArray<WithId<Required<TSchema>>[Key]>>>,
    ): void;
    distinct(key: string, callback: MongoCallback<any[]>): void;
    distinct(key: string, query: FilterQuery<TSchema>, callback: MongoCallback<any[]>): void;
    distinct(key: string, query?: FilterQuery<TSchema>, options?: MongoDistinctPreferences): Promise<any[]>;
    distinct(
        key: string,
        query: FilterQuery<TSchema>,
        options: MongoDistinctPreferences,
        callback: MongoCallback<any[]>,
    ): void;
    drop(options?: { session: ClientSession }): Promise<any>;
    drop(callback: MongoCallback<any>): void;
    drop(options: { session: ClientSession }, callback: MongoCallback<any>): void;
    dropIndex(indexName: string, callback: MongoCallback<any>): void;
    dropIndex(indexName: string, options?: CommonOptions & { maxTimeMS?: number | undefined }): Promise<any>;
    dropIndex(indexName: string, options: CommonOptions & { maxTimeMS?: number | undefined }, callback: MongoCallback<any>): void;
    dropIndexes(options?: { session?: ClientSession | undefined; maxTimeMS?: number | undefined }): Promise<any>;
    dropIndexes(callback?: MongoCallback<any>): void;
    dropIndexes(options: { session?: ClientSession | undefined; maxTimeMS?: number | undefined }, callback: MongoCallback<any>): void;
    estimatedDocumentCount(callback: MongoCallback<number>): void;
    estimatedDocumentCount(query: FilterQuery<TSchema>, callback: MongoCallback<number>): void;
    estimatedDocumentCount(query?: FilterQuery<TSchema>, options?: MongoCountPreferences): Promise<number>;
    estimatedDocumentCount(
        query: FilterQuery<TSchema>,
        options: MongoCountPreferences,
        callback: MongoCallback<number>,
    ): void;
    find(query?: FilterQuery<TSchema>): Cursor<TSchema>;
    find(query: FilterQuery<TSchema>, options?: WithoutProjection<FindOneOptions<TSchema>>): Cursor<TSchema>;
    find<T = TSchema>(query: FilterQuery<TSchema>, options: FindOneOptions<T extends TSchema ? TSchema : T>): Cursor<T>;
    findOne(filter: FilterQuery<TSchema>, callback: MongoCallback<TSchema>): void;
    findOne(
        filter: FilterQuery<TSchema>,
        options?: WithoutProjection<FindOneOptions<TSchema>>,
    ): Promise<TSchema | null>;
    findOne<T = TSchema>(
        filter: FilterQuery<TSchema>,
        options?: FindOneOptions<T extends TSchema ? TSchema : T>,
    ): Promise<T | null>;
    findOne(
        filter: FilterQuery<TSchema>,
        options: WithoutProjection<FindOneOptions<TSchema>>,
        callback: MongoCallback<TSchema | null>,
    ): void;
    findOne<T = TSchema>(
        filter: FilterQuery<TSchema>,
        options: FindOneOptions<T extends TSchema ? TSchema : T>,
        callback: MongoCallback<T extends TSchema ? TSchema : T | null>,
    ): void;
    findOneAndDelete(
        filter: FilterQuery<TSchema>,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    findOneAndDelete(
        filter: FilterQuery<TSchema>,
        options?: FindOneAndDeleteOption<TSchema>,
    ): Promise<FindAndModifyWriteOpResultObject<TSchema>>;
    findOneAndDelete(
        filter: FilterQuery<TSchema>,
        options: FindOneAndDeleteOption<TSchema>,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    findOneAndReplace(
        filter: FilterQuery<TSchema>,
        replacement: object,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    findOneAndReplace(
        filter: FilterQuery<TSchema>,
        replacement: object,
        options?: FindOneAndReplaceOption<TSchema>,
    ): Promise<FindAndModifyWriteOpResultObject<TSchema>>;
    findOneAndReplace(
        filter: FilterQuery<TSchema>,
        replacement: object,
        options: FindOneAndReplaceOption<TSchema>,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    findOneAndUpdate(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | TSchema,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    findOneAndUpdate(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | TSchema,
        options?: FindOneAndUpdateOption<TSchema>,
    ): Promise<FindAndModifyWriteOpResultObject<TSchema>>;
    findOneAndUpdate(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | TSchema,
        options: FindOneAndUpdateOption<TSchema>,
        callback: MongoCallback<FindAndModifyWriteOpResultObject<TSchema>>,
    ): void;
    geoHaystackSearch(x: number, y: number, callback: MongoCallback<any>): void;
    geoHaystackSearch(x: number, y: number, options?: GeoHaystackSearchOptions): Promise<any>;
    geoHaystackSearch(x: number, y: number, options: GeoHaystackSearchOptions, callback: MongoCallback<any>): void;
    group(
        keys: object | any[] | Function | Code,
        condition: object,
        initial: object,
        reduce: Function | Code,
        finalize: Function | Code,
        command: boolean,
        callback: MongoCallback<any>,
    ): void;
    group(
        keys: object | any[] | Function | Code,
        condition: object,
        initial: object,
        reduce: Function | Code,
        finalize: Function | Code,
        command: boolean,
        options?: { readPreference?: ReadPreferenceOrMode | undefined; session?: ClientSession | undefined },
    ): Promise<any>;
    group(
        keys: object | any[] | Function | Code,
        condition: object,
        initial: object,
        reduce: Function | Code,
        finalize: Function | Code,
        command: boolean,
        options: {
            readPreference?: ReadPreferenceOrMode | undefined;
            session?: ClientSession | undefined;
        },
        callback: MongoCallback<any>,
    ): void;
    indexes(options?: { session: ClientSession }): Promise<any>;
    indexes(callback: MongoCallback<any>): void;
    indexes(options: { session?: ClientSession | undefined }, callback: MongoCallback<any>): void;
    indexExists(indexes: string | string[], callback: MongoCallback<boolean>): void;
    indexExists(indexes: string | string[], options?: { session: ClientSession }): Promise<boolean>;
    indexExists(
        indexes: string | string[],
        options: { session: ClientSession },
        callback: MongoCallback<boolean>,
    ): void;
    indexInformation(callback: MongoCallback<any>): void;
    indexInformation(options?: { full: boolean; session: ClientSession }): Promise<any>;
    indexInformation(options: { full: boolean; session: ClientSession }, callback: MongoCallback<any>): void;
    initializeOrderedBulkOp(options?: CommonOptions): OrderedBulkOperation;
    initializeUnorderedBulkOp(options?: CommonOptions): UnorderedBulkOperation;
    insert(docs: OptionalId<TSchema>, callback: MongoCallback<InsertWriteOpResult<WithId<TSchema>>>): void;
    insert(
        docs: OptionalId<TSchema>,
        options?: CollectionInsertOneOptions,
    ): Promise<InsertWriteOpResult<WithId<TSchema>>>;
    insert(
        docs: OptionalId<TSchema>,
        options: CollectionInsertOneOptions,
        callback: MongoCallback<InsertWriteOpResult<WithId<TSchema>>>,
    ): void;
    insertMany(docs: Array<OptionalId<TSchema>>, callback: MongoCallback<InsertWriteOpResult<WithId<TSchema>>>): void;
    insertMany(
        docs: Array<OptionalId<TSchema>>,
        options?: CollectionInsertManyOptions,
    ): Promise<InsertWriteOpResult<WithId<TSchema>>>;
    insertMany(
        docs: Array<OptionalId<TSchema>>,
        options: CollectionInsertManyOptions,
        callback: MongoCallback<InsertWriteOpResult<WithId<TSchema>>>,
    ): void;
    insertOne(docs: OptionalId<TSchema>, callback: MongoCallback<InsertOneWriteOpResult<WithId<TSchema>>>): void;
    insertOne(
        docs: OptionalId<TSchema>,
        options?: CollectionInsertOneOptions,
    ): Promise<InsertOneWriteOpResult<WithId<TSchema>>>;
    insertOne(
        docs: OptionalId<TSchema>,
        options: CollectionInsertOneOptions,
        callback: MongoCallback<InsertOneWriteOpResult<WithId<TSchema>>>,
    ): void;
    isCapped(options?: { session: ClientSession }): Promise<any>;
    isCapped(callback: MongoCallback<any>): void;
    isCapped(options: { session: ClientSession }, callback: MongoCallback<any>): void;
    listIndexes(options?: {
        batchSize?: number | undefined;
        readPreference?: ReadPreferenceOrMode | undefined;
        session?: ClientSession | undefined;
    }): CommandCursor;
    mapReduce<TKey, TValue>(
        map: CollectionMapFunction<TSchema> | string,
        reduce: CollectionReduceFunction<TKey, TValue> | string,
        callback: MongoCallback<any>,
    ): void;
    mapReduce<TKey, TValue>(
        map: CollectionMapFunction<TSchema> | string,
        reduce: CollectionReduceFunction<TKey, TValue> | string,
        options?: MapReduceOptions,
    ): Promise<any>;
    mapReduce<TKey, TValue>(
        map: CollectionMapFunction<TSchema> | string,
        reduce: CollectionReduceFunction<TKey, TValue> | string,
        options: MapReduceOptions,
        callback: MongoCallback<any>,
    ): void;
    options(options?: { session: ClientSession }): Promise<any>;
    options(callback: MongoCallback<any>): void;
    options(options: { session: ClientSession }, callback: MongoCallback<any>): void;
    parallelCollectionScan(callback: MongoCallback<Array<Cursor<any>>>): void;
    parallelCollectionScan(options?: ParallelCollectionScanOptions): Promise<Array<Cursor<any>>>;
    parallelCollectionScan(options: ParallelCollectionScanOptions, callback: MongoCallback<Array<Cursor<any>>>): void;
    reIndex(options?: { session: ClientSession }): Promise<any>;
    reIndex(callback: MongoCallback<any>): void;
    reIndex(options: { session: ClientSession }, callback: MongoCallback<any>): void;
    remove(selector: object, callback: MongoCallback<WriteOpResult>): void;
    remove(selector: object, options?: CommonOptions & { single?: boolean | undefined }): Promise<WriteOpResult>;
    remove(
        selector: object,
        options?: CommonOptions & { single?: boolean | undefined },
        callback?: MongoCallback<WriteOpResult>,
    ): void;
    rename(newName: string, callback: MongoCallback<Collection<TSchema>>): void;
    rename(newName: string, options?: { dropTarget?: boolean | undefined; session?: ClientSession | undefined }): Promise<Collection<TSchema>>;
    rename(
        newName: string,
        options: { dropTarget?: boolean | undefined; session?: ClientSession | undefined },
        callback: MongoCallback<Collection<TSchema>>,
    ): void;
    replaceOne(filter: FilterQuery<TSchema>, doc: TSchema, callback: MongoCallback<ReplaceWriteOpResult>): void;
    replaceOne(filter: FilterQuery<TSchema>, doc: TSchema, options?: ReplaceOneOptions): Promise<ReplaceWriteOpResult>;
    replaceOne(
        filter: FilterQuery<TSchema>,
        doc: TSchema,
        options: ReplaceOneOptions,
        callback: MongoCallback<ReplaceWriteOpResult>,
    ): void;
    save(doc: TSchema, callback: MongoCallback<WriteOpResult>): void;
    save(doc: TSchema, options?: CommonOptions): Promise<WriteOpResult>;
    save(doc: TSchema, options: CommonOptions, callback: MongoCallback<WriteOpResult>): void;
    stats(callback: MongoCallback<CollStats>): void;
    stats(options?: { scale: number; session?: ClientSession | undefined }): Promise<CollStats>;
    stats(options: { scale: number; session?: ClientSession | undefined }, callback: MongoCallback<CollStats>): void;
    update(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        callback: MongoCallback<WriteOpResult>,
    ): void;
    update(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options?: UpdateOneOptions & { multi?: boolean | undefined },
    ): Promise<WriteOpResult>;
    update(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options: UpdateOneOptions & { multi?: boolean | undefined },
        callback: MongoCallback<WriteOpResult>,
    ): void;
    updateMany(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        callback: MongoCallback<UpdateWriteOpResult>,
    ): void;
    updateMany(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options?: UpdateManyOptions,
    ): Promise<UpdateWriteOpResult>;
    updateMany(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options: UpdateManyOptions,
        callback: MongoCallback<UpdateWriteOpResult>,
    ): void;
    updateOne(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        callback: MongoCallback<UpdateWriteOpResult>,
    ): void;
    updateOne(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options?: UpdateOneOptions,
    ): Promise<UpdateWriteOpResult>;
    updateOne(
        filter: FilterQuery<TSchema>,
        update: UpdateQuery<TSchema> | Partial<TSchema>,
        options: UpdateOneOptions,
        callback: MongoCallback<UpdateWriteOpResult>,
    ): void;
    watch<T = TSchema>(
        pipeline?: object[],
        options?: ChangeStreamOptions & { session?: ClientSession | undefined },
    ): ChangeStream<T>;
    watch<T = TSchema>(options?: ChangeStreamOptions & { session?: ClientSession | undefined }): ChangeStream<T>;
}

type KeysOfAType<TSchema, Type> = {
    [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;
}[keyof TSchema];
type KeysOfOtherType<TSchema, Type> = {
    [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;
}[keyof TSchema];

type AcceptedFields<TSchema, FieldType, AssignableType> = {
    readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;
};

type NotAcceptedFields<TSchema, FieldType> = {
    readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;
};

type DotAndArrayNotation<AssignableType> = {
    readonly [key: string]: AssignableType;
};

type ReadonlyPartial<TSchema> = {
    readonly [key in keyof TSchema]?: TSchema[key];
};

export type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = AcceptedFields<
    TSchema,
    FieldType,
    AssignableType
> &
    NotAcceptedFields<TSchema, FieldType> &
    DotAndArrayNotation<AssignableType>;

export type MatchKeysAndValues<TSchema> = ReadonlyPartial<TSchema> & DotAndArrayNotation<any>;

type Unpacked<Type> = Type extends ReadonlyArray<infer Element> ? Element : Type;

type UpdateOptionalId<T> = T extends { _id?: any } ? OptionalId<T> : T;

export type SortValues = -1 | 1;
export type MetaSortOperators = "textScore" | "indexKey";

export type MetaProjectionOperators =
    | MetaSortOperators
    | "searchScore"
    | "searchHighlights";

export type SchemaMember<T, V> = { [P in keyof T]?: V } | { [key: string]: V };

export type SortOptionObject<T> = SchemaMember<T, number | { $meta?: MetaSortOperators | undefined }>;

export type AddToSetOperators<Type> = {
    $each: Type;
};

export type ArrayOperator<Type> = {
    $each: Type;
    $slice?: number | undefined;
    $position?: number | undefined;
    $sort?: SortValues | Record<string, SortValues> | undefined;
};

export type SetFields<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?:
        | UpdateOptionalId<Unpacked<TSchema[key]>>
        | AddToSetOperators<Array<UpdateOptionalId<Unpacked<TSchema[key]>>>>;
} &
    NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>) & {
    readonly [key: string]: AddToSetOperators<any> | any;
};

export type PushOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:
        | Unpacked<TSchema[key]>
        | ArrayOperator<Array<Unpacked<TSchema[key]>>>;
} &
    NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: ArrayOperator<any> | any;
};

export type PullOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:
        | Partial<Unpacked<TSchema[key]>>
        | ObjectQuerySelector<Unpacked<TSchema[key]>>;
} &
    NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: QuerySelector<any> | any;
};

export type PullAllOperator<TSchema> = ({
    readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];
} &
    NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {
    readonly [key: string]: any[];
};

export type UpdateQuery<TSchema> = {
    $currentDate?: OnlyFieldsOfType<TSchema, Date | Timestamp, true | { $type: "date" | "timestamp" }> | undefined;
    $inc?: OnlyFieldsOfType<TSchema, NumericTypes | undefined> | undefined;
    $min?: MatchKeysAndValues<TSchema> | undefined;
    $max?: MatchKeysAndValues<TSchema> | undefined;
    $mul?: OnlyFieldsOfType<TSchema, NumericTypes | undefined> | undefined;
    $rename?: { [key: string]: string } | undefined;
    $set?: MatchKeysAndValues<TSchema> | undefined;
    $setOnInsert?: MatchKeysAndValues<TSchema> | undefined;
    $unset?: OnlyFieldsOfType<TSchema, any, "" | 1 | true> | undefined;

    $addToSet?: SetFields<TSchema> | undefined;
    $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1> | undefined;
    $pull?: PullOperator<TSchema> | undefined;
    $push?: PushOperator<TSchema> | undefined;
    $pullAll?: PullAllOperator<TSchema> | undefined;

    $bit?: {
        [key: string]: { [key in "and" | "or" | "xor"]?: number };
    } | undefined;
};

export enum BSONType {
    Double = 1,
    String,
    Object,
    Array,
    BinData,
    Undefined,
    ObjectId,
    Boolean,
    Date,
    Null,
    Regex,
    DBPointer,
    JavaScript,
    Symbol,
    JavaScriptWithScope,
    Int,
    Timestamp,
    Long,
    Decimal,
    MinKey = -1,
    MaxKey = 127,
}

type BSONTypeAlias =
    | "number"
    | "double"
    | "string"
    | "object"
    | "array"
    | "binData"
    | "undefined"
    | "objectId"
    | "bool"
    | "date"
    | "null"
    | "regex"
    | "dbPointer"
    | "javascript"
    | "symbol"
    | "javascriptWithScope"
    | "int"
    | "timestamp"
    | "long"
    | "decimal"
    | "minKey"
    | "maxKey";

type BitwiseQuery =
    | number 
    | Binary 
    | number[]; 

type RegExpForString<T> = T extends string ? RegExp | T : T;
type MongoAltQuery<T> = T extends ReadonlyArray<infer U> ? T | RegExpForString<U> : RegExpForString<T>;
export type QuerySelector<T> = {
    $eq?: T | undefined;
    $gt?: T | undefined;
    $gte?: T | undefined;
    $in?: T[] | undefined;
    $lt?: T | undefined;
    $lte?: T | undefined;
    $ne?: T | undefined;
    $nin?: T[] | undefined;
    $not?: T extends string ? QuerySelector<T> | RegExp : QuerySelector<T> | undefined;
    $exists?: boolean | undefined;
    $type?: BSONType | BSONTypeAlias | undefined;
    $expr?: any;
    $jsonSchema?: any;
    $mod?: T extends number ? [number, number] : never | undefined;
    $regex?: T extends string ? RegExp | string : never | undefined;
    $options?: T extends string ? string : never | undefined;
    $geoIntersects?: { $geometry: object } | undefined;
    $geoWithin?: object | undefined;
    $near?: object | undefined;
    $nearSphere?: object | undefined;
    $maxDistance?: number | undefined;
    $all?: T extends ReadonlyArray<infer U> ? any[] : never | undefined;
    $elemMatch?: T extends ReadonlyArray<infer U> ? object : never | undefined;
    $size?: T extends ReadonlyArray<infer U> ? number : never | undefined;
    $bitsAllClear?: BitwiseQuery | undefined;
    $bitsAllSet?: BitwiseQuery | undefined;
    $bitsAnyClear?: BitwiseQuery | undefined;
    $bitsAnySet?: BitwiseQuery | undefined;
};

export type RootQuerySelector<T> = {
    $and?: Array<FilterQuery<T>> | undefined;
    $nor?: Array<FilterQuery<T>> | undefined;
    $or?: Array<FilterQuery<T>> | undefined;
    $text?: {
        $search: string;
        $language?: string | undefined;
        $caseSensitive?: boolean | undefined;
        $diacriticSensitive?: boolean | undefined;
    } | undefined;
    $where?: string | Function | undefined;
    $comment?: string | undefined;
    [key: string]: any;
};

export type ObjectQuerySelector<T> = T extends object ? { [key in keyof T]?: QuerySelector<T[key]> } : QuerySelector<T>;

export type Condition<T> = MongoAltQuery<T> | QuerySelector<MongoAltQuery<T>>;

export type FilterQuery<T> = {
    [P in keyof T]?: Condition<T[P]>;
} &
    RootQuerySelector<T>;
export type BulkWriteInsertOneOperation<TSchema> = {
    insertOne: {
        document: OptionalId<TSchema>;
    };
};

export type BulkWriteUpdateOperation<TSchema> = {
    arrayFilters?: object[] | undefined;
    collation?: object | undefined;
    filter: FilterQuery<TSchema>;
    update: UpdateQuery<TSchema>;
    upsert?: boolean | undefined;
};
export type BulkWriteUpdateOneOperation<TSchema> = {
    updateOne: BulkWriteUpdateOperation<TSchema>;
};
export type BulkWriteUpdateManyOperation<TSchema> = {
    updateMany: BulkWriteUpdateOperation<TSchema>;
};
export type BulkWriteReplaceOneOperation<TSchema> = {
    replaceOne: {
        collation?: object | undefined;
        filter: FilterQuery<TSchema>;
        replacement: TSchema;
        upsert?: boolean | undefined;
    };
};

export type BulkWriteDeleteOperation<TSchema> = {
    collation?: object | undefined;
    filter: FilterQuery<TSchema>;
};
export type BulkWriteDeleteOneOperation<TSchema> = {
    deleteOne: BulkWriteDeleteOperation<TSchema>;
};
export type BulkWriteDeleteManyOperation<TSchema> = {
    deleteMany: BulkWriteDeleteOperation<TSchema>;
};

export type BulkWriteOperation<TSchema> =
    | BulkWriteInsertOneOperation<TSchema>
    | BulkWriteUpdateOneOperation<TSchema>
    | BulkWriteUpdateManyOperation<TSchema>
    | BulkWriteReplaceOneOperation<TSchema>
    | BulkWriteDeleteOneOperation<TSchema>
    | BulkWriteDeleteManyOperation<TSchema>;

export interface CollStats {
    ns: string;
    count: number;
    size: number;
    avgObjSize: number;
    storageSize: number;
    numExtents: number;
    nindexes: number;
    lastExtentSize: number;
    paddingFactor: number;
    userFlags?: number | undefined;
    totalIndexSize: number;
    indexSizes: {
        _id_: number;
        [index: string]: number;
    };
    capped: boolean;
    max: number;
    maxSize: number;
    wiredTiger?: WiredTigerData | undefined;
    indexDetails?: any;
    ok: number;
}

export interface WiredTigerData {
    LSM: {
        "bloom filter false positives": number;
        "bloom filter hits": number;
        "bloom filter misses": number;
        "bloom filter pages evicted from cache": number;
        "bloom filter pages read into cache": number;
        "bloom filters in the LSM tree": number;
        "chunks in the LSM tree": number;
        "highest merge generation in the LSM tree": number;
        "queries that could have benefited from a Bloom filter that did not exist": number;
        "sleep for LSM checkpoint throttle": number;
        "sleep for LSM merge throttle": number;
        "total size of bloom filters": number;
    };
    "block-manager": {
        "allocations requiring file extension": number;
        "blocks allocated": number;
        "blocks freed": number;
        "checkpoint size": number;
        "file allocation unit size": number;
        "file bytes available for reuse": number;
        "file magic number": number;
        "file major version number": number;
        "file size in bytes": number;
        "minor version number": number;
    };
    btree: {
        "btree checkpoint generation": number;
        "column-store fixed-size leaf pages": number;
        "column-store internal pages": number;
        "column-store variable-size RLE encoded values": number;
        "column-store variable-size deleted values": number;
        "column-store variable-size leaf pages": number;
        "fixed-record size": number;
        "maximum internal page key size": number;
        "maximum internal page size": number;
        "maximum leaf page key size": number;
        "maximum leaf page size": number;
        "maximum leaf page value size": number;
        "maximum tree depth": number;
        "number of key/value pairs": number;
        "overflow pages": number;
        "pages rewritten by compaction": number;
        "row-store internal pages": number;
        "row-store leaf pages": number;
    };
    cache: {
        "bytes currently in the cache": number;
        "bytes read into cache": number;
        "bytes written from cache": number;
        "checkpoint blocked page eviction": number;
        "data source pages selected for eviction unable to be evicted": number;
        "hazard pointer blocked page eviction": number;
        "in-memory page passed criteria to be split": number;
        "in-memory page splits": number;
        "internal pages evicted": number;
        "internal pages split during eviction": number;
        "leaf pages split during eviction": number;
        "modified pages evicted": number;
        "overflow pages read into cache": number;
        "overflow values cached in memory": number;
        "page split during eviction deepened the tree": number;
        "page written requiring lookaside records": number;
        "pages read into cache": number;
        "pages read into cache requiring lookaside entries": number;
        "pages requested from the cache": number;
        "pages written from cache": number;
        "pages written requiring in-memory restoration": number;
        "tracked dirty bytes in the cache": number;
        "unmodified pages evicted": number;
    };
    cache_walk: {
        "Average difference between current eviction generation when the page was last considered": number;
        "Average on-disk page image size seen": number;
        "Clean pages currently in cache": number;
        "Current eviction generation": number;
        "Dirty pages currently in cache": number;
        "Entries in the root page": number;
        "Internal pages currently in cache": number;
        "Leaf pages currently in cache": number;
        "Maximum difference between current eviction generation when the page was last considered": number;
        "Maximum page size seen": number;
        "Minimum on-disk page image size seen": number;
        "On-disk page image sizes smaller than a single allocation unit": number;
        "Pages created in memory and never written": number;
        "Pages currently queued for eviction": number;
        "Pages that could not be queued for eviction": number;
        "Refs skipped during cache traversal": number;
        "Size of the root page": number;
        "Total number of pages currently in cache": number;
    };
    compression: {
        "compressed pages read": number;
        "compressed pages written": number;
        "page written failed to compress": number;
        "page written was too small to compress": number;
        "raw compression call failed, additional data available": number;
        "raw compression call failed, no additional data available": number;
        "raw compression call succeeded": number;
    };
    cursor: {
        "bulk-loaded cursor-insert calls": number;
        "create calls": number;
        "cursor-insert key and value bytes inserted": number;
        "cursor-remove key bytes removed": number;
        "cursor-update value bytes updated": number;
        "insert calls": number;
        "next calls": number;
        "prev calls": number;
        "remove calls": number;
        "reset calls": number;
        "restarted searches": number;
        "search calls": number;
        "search near calls": number;
        "truncate calls": number;
        "update calls": number;
    };
    reconciliation: {
        "dictionary matches": number;
        "fast-path pages deleted": number;
        "internal page key bytes discarded using suffix compression": number;
        "internal page multi-block writes": number;
        "internal-page overflow keys": number;
        "leaf page key bytes discarded using prefix compression": number;
        "leaf page multi-block writes": number;
        "leaf-page overflow keys": number;
        "maximum blocks required for a page": number;
        "overflow values written": number;
        "page checksum matches": number;
        "page reconciliation calls": number;
        "page reconciliation calls for eviction": number;
        "pages deleted": number;
    };
}

export interface CollectionAggregationOptions {
    readPreference?: ReadPreferenceOrMode | undefined;
    cursor?: { batchSize?: number | undefined } | undefined;
    explain?: boolean | undefined;
    allowDiskUse?: boolean | undefined;
    maxTimeMS?: number | undefined;
    bypassDocumentValidation?: boolean | undefined;
    hint?: string | object | undefined;
    raw?: boolean | undefined;
    promoteLongs?: boolean | undefined;
    promoteValues?: boolean | undefined;
    promoteBuffers?: boolean | undefined;
    collation?: CollationDocument | undefined;
    comment?: string | undefined;
    session?: ClientSession | undefined;
}

export interface CollectionInsertManyOptions extends CommonOptions {
    serializeFunctions?: boolean | undefined;
    forceServerObjectId?: boolean | undefined;
    bypassDocumentValidation?: boolean | undefined;
    ordered?: boolean | undefined;
}
export interface CollectionBulkWriteOptions extends CommonOptions {
    serializeFunctions?: boolean | undefined;
    ordered?: boolean | undefined;
    bypassDocumentValidation?: boolean | undefined;
    forceServerObjectId?: boolean | undefined;
}

export interface BulkWriteOpResultObject {
    insertedCount?: number | undefined;
    matchedCount?: number | undefined;
    modifiedCount?: number | undefined;
    deletedCount?: number | undefined;
    upsertedCount?: number | undefined;
    insertedIds?: { [index: number]: any } | undefined;
    upsertedIds?: { [index: number]: any } | undefined;
    result?: any;
}
export interface MongoCountPreferences {
    limit?: number | undefined;
    skip?: number | undefined;
    hint?: string | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    maxTimeMS?: number | undefined;
    session?: ClientSession | undefined;
}

export interface MongoDistinctPreferences {
    readPreference?: ReadPreferenceOrMode | undefined;
    maxTimeMS?: number | undefined;
    session?: ClientSession | undefined;
}

export interface DeleteWriteOpResultObject {
    result: {
        ok?: number | undefined;
        n?: number | undefined;
    };
    connection?: any;
    deletedCount?: number | undefined;
}

export interface FindAndModifyWriteOpResultObject<TSchema> {
    value?: TSchema | undefined;
    lastErrorObject?: any;
    ok?: number | undefined;
}

export interface FindOneAndReplaceOption<T> extends CommonOptions {
    projection?: SchemaMember<T, ProjectionOperators | number | boolean | any> | undefined;
    sort?: SortOptionObject<T> | undefined;
    maxTimeMS?: number | undefined;
    upsert?: boolean | undefined;
    returnDocument?: 'after' | 'before' | undefined;
    returnOriginal?: boolean | undefined;
    collation?: CollationDocument | undefined;
}

export interface ProjectionOperators {
    $elemMatch?: object | undefined;
    $slice?: number | [number, number] | undefined;
    $meta?: MetaProjectionOperators | undefined;
}

export interface FindOneAndUpdateOption<T> extends FindOneAndReplaceOption<T> {
    arrayFilters?: object[] | undefined;
}

export interface FindOneAndDeleteOption<T> {
    projection?: SchemaMember<T, ProjectionOperators | number | boolean | any> | undefined;
    sort?: SortOptionObject<T> | undefined;
    maxTimeMS?: number | undefined;
    session?: ClientSession | undefined;
    collation?: CollationDocument | undefined;
}

export interface GeoHaystackSearchOptions {
    readPreference?: ReadPreferenceOrMode | undefined;
    maxDistance?: number | undefined;
    search?: object | undefined;
    limit?: number | undefined;
    session?: ClientSession | undefined;
}

export class Code {
    constructor(code: string | Function, scope?: object);
    code: string | Function;
    scope: any;
}

export interface OrderedBulkOperation {
    length: number;
    execute(callback: MongoCallback<BulkWriteResult>): void;
    execute(options?: FSyncOptions): Promise<BulkWriteResult>;
    execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
    find(selector: object): FindOperators;
    insert(document: object): OrderedBulkOperation;
}

export interface BulkWriteResultUpsertedIdObject {
    index: number;
    _id: ObjectId;
}

export interface BulkWriteResult {
    ok: boolean;
    nInserted: number;
    nMatched: number;
    nModified: number;
    nUpserted: number;
    nRemoved: number;
    getInsertedIds(): object[];
    getLastOp(): object;
    getRawResponse(): object;
    getUpsertedIdAt(index: number): BulkWriteResultUpsertedIdObject;
    getUpsertedIds(): BulkWriteResultUpsertedIdObject[];
    getWriteConcernError(): WriteConcernError;
    getWriteErrorAt(index: number): WriteError;
    getWriteErrorCount(): number;
    getWriteErrors(): object[];
    hasWriteErrors(): boolean;
}

export interface WriteError {
    code: number;
    index: number;
    errmsg: string;
}

export interface WriteConcernError {
    code: number;
    errmsg: string;
}

export interface FindOperators {
    delete(): OrderedBulkOperation;
    deleteOne(): OrderedBulkOperation;
    remove(): OrderedBulkOperation;
    removeOne(): OrderedBulkOperation;
    replaceOne(replacement: object): OrderedBulkOperation;
    update(updateDocument: object, options?: { hint: object }): OrderedBulkOperation;
    updateOne(updateDocument: object, options?: { hint: object }): OrderedBulkOperation;
    upsert(): FindOperators;
}

export interface UnorderedBulkOperation {
    length: number;
    execute(callback: MongoCallback<BulkWriteResult>): void;
    execute(options?: FSyncOptions): Promise<BulkWriteResult>;
    execute(options: FSyncOptions, callback: MongoCallback<BulkWriteResult>): void;
    find(selector: object): FindOperators;
    insert(document: object): UnorderedBulkOperation;
}

export interface FindOneOptions<T> {
    limit?: number | undefined;
    sort?: Array<[string, number]> | SortOptionObject<T> | undefined;
    projection?: SchemaMember<T, ProjectionOperators | number | boolean | any> | undefined;
    fields?: { [P in keyof T]: boolean | number } | undefined;
    skip?: number | undefined;
    hint?: object | undefined;
    explain?: boolean | undefined;
    snapshot?: boolean | undefined;
    timeout?: boolean | undefined;
    tailable?: boolean | undefined;
    awaitData?: boolean | undefined;
    batchSize?: number | undefined;
    returnKey?: boolean | undefined;
    maxScan?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
    showDiskLoc?: boolean | undefined;
    comment?: string | undefined;
    raw?: boolean | undefined;
    promoteLongs?: boolean | undefined;
    promoteValues?: boolean | undefined;
    promoteBuffers?: boolean | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
    partial?: boolean | undefined;
    maxTimeMS?: number | undefined;
    collation?: CollationDocument | undefined;
    session?: ClientSession | undefined;
}

export interface CollectionInsertOneOptions extends CommonOptions {
    serializeFunctions?: boolean | undefined;
    forceServerObjectId?: boolean | undefined;
    bypassDocumentValidation?: boolean | undefined;
}


export interface InsertWriteOpResult<TSchema extends { _id: any }> {
    insertedCount: number;
    ops: TSchema[];
    insertedIds: { [key: number]: TSchema["_id"] };
    connection: any;
    result: { ok: number; n: number };
}

export interface InsertOneWriteOpResult<TSchema extends { _id: any }> {
    insertedCount: number;
    ops: TSchema[];
    insertedId: TSchema["_id"];
    connection: any;
    result: { ok: number; n: number };
}

export interface ParallelCollectionScanOptions {
    readPreference?: ReadPreferenceOrMode | undefined;
    batchSize?: number | undefined;
    numCursors?: number | undefined;
    raw?: boolean | undefined;
    session?: ClientSession | undefined;
}

export interface ReplaceOneOptions extends CommonOptions {
    upsert?: boolean | undefined;
    bypassDocumentValidation?: boolean | undefined;
}

export interface UpdateOneOptions extends ReplaceOneOptions {
    arrayFilters?: object[] | undefined;
}

export interface UpdateManyOptions extends CommonOptions {
    upsert?: boolean | undefined;
    arrayFilters?: object[] | undefined;
}

export interface UpdateWriteOpResult {
    result: { ok: number; n: number; nModified: number };
    connection: any;
    matchedCount: number;
    modifiedCount: number;
    upsertedCount: number;
    upsertedId: { _id: ObjectId };
}

export interface ReplaceWriteOpResult extends UpdateWriteOpResult {
    ops: any[];
}

export interface MapReduceOptions {
    readPreference?: ReadPreferenceOrMode | undefined;
    out?: object | undefined;
    query?: object | undefined;
    sort?: object | undefined;
    limit?: number | undefined;
    keeptemp?: boolean | undefined;
    finalize?: Function | string | undefined;
    scope?: object | undefined;
    jsMode?: boolean | undefined;
    verbose?: boolean | undefined;
    bypassDocumentValidation?: boolean | undefined;
    session?: ClientSession | undefined;
}

export type CollectionMapFunction<TSchema> = (this: TSchema) => void;

export type CollectionReduceFunction<TKey, TValue> = (key: TKey, values: TValue[]) => TValue;

export interface WriteOpResult {
    ops: any[];
    connection: any;
    result: any;
}

export type CursorResult = object | null | boolean;

type Default = any;
type DefaultSchema = any;

export class Cursor<T = Default> extends Readable {
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    sortValue: string;
    timeout: boolean;
    readPreference: ReadPreference;
    addCursorFlag(flag: 'tailable' | 'oplogReplay' | 'noCursorTimeout' | 'awaitData' | 'partial' | string, value: boolean): Cursor<T>;
    addQueryModifier(name: string, value: boolean | string | number): Cursor<T>;
    batchSize(value: number): Cursor<T>;
    clone(): Cursor<T>; 
    close(options?: { skipKillCursors: boolean }): Promise<CursorResult>;
    close(options: { skipKillCursors: boolean }, callback: MongoCallback<CursorResult>): void;
    close(callback: MongoCallback<CursorResult>): void;
    collation(value: CollationDocument): Cursor<T>;
    comment(value: string): Cursor<T>;
    count(callback: MongoCallback<number>): void;
    count(applySkipLimit: boolean, callback: MongoCallback<number>): void;
    count(options: CursorCommentOptions, callback: MongoCallback<number>): void;
    count(applySkipLimit: boolean, options: CursorCommentOptions, callback: MongoCallback<number>): void;
    count(applySkipLimit?: boolean, options?: CursorCommentOptions): Promise<number>;
    explain(verbosity?: string | boolean, callback?: MongoCallback<CursorResult>): Promise<CursorResult>;
    explain(callback?: MongoCallback<CursorResult>): void;
    filter(filter: object): Cursor<T>;
    forEach(iterator: IteratorCallback<T>, callback: EndCallback): void;
    forEach(iterator: IteratorCallback<T>): Promise<void>;
    hasNext(): Promise<boolean>;
    hasNext(callback: MongoCallback<boolean>): void;
    hint(hint: string | object): Cursor<T>;
    isClosed(): boolean;
    limit(value: number): Cursor<T>;
    map<U>(transform: (document: T) => U): Cursor<U>;
    max(max: object): Cursor<T>;
    maxAwaitTimeMS(value: number): Cursor<T>;
    maxScan(maxScan: object): Cursor<T>;
    maxTimeMS(value: number): Cursor<T>;
    min(min: object): Cursor<T>;
    next(): Promise<T | null>;
    next(callback: MongoCallback<T | null>): void;
    project<U = T>(value: SchemaMember<T, ProjectionOperators | number | boolean | any>): Cursor<U>;
    read(size?: number): string | Buffer | void;
    returnKey(returnKey: boolean): Cursor<T>;
    rewind(): void;
    setCursorOption(field: string, value: object): Cursor<T>;
    setReadPreference(readPreference: ReadPreferenceOrMode): Cursor<T>;
    showRecordId(showRecordId: boolean): Cursor<T>;
    skip(value: number): Cursor<T>;
    snapshot(snapshot: object): Cursor<T>;
    sort(keyOrList: string | Array<[string, number]> | SortOptionObject<T>, direction?: number): Cursor<T>;
    stream(options?: { transform?: ((document: T) => any) | undefined }): Cursor<T>;
    toArray(): Promise<T[]>;
    toArray(callback: MongoCallback<T[]>): void;
    transformStream(options?: { transform?: ((document: T) => any) | undefined }): Cursor<T>;
    unshift(chunk: Buffer | string): void;
}

export interface CursorCommentOptions {
    skip?: number | undefined;
    limit?: number | undefined;
    maxTimeMS?: number | undefined;
    hint?: string | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
}

export interface IteratorCallback<T> {
    (doc: T): void;
}
export interface EndCallback {
    (error: MongoError): void;
}
export type AggregationCursorResult = object | null;
export class AggregationCursor<T = Default> extends Cursor<T> {
    batchSize(value: number): AggregationCursor<T>;
    clone(): AggregationCursor<T>;
    close(): Promise<AggregationCursorResult>;
    close(callback: MongoCallback<AggregationCursorResult>): void;
    each(callback: MongoCallback<AggregationCursorResult>): void;
    explain(
        verbosity?: string | boolean,
        callback?: MongoCallback<AggregationCursorResult>,
    ): Promise<AggregationCursorResult>;
    explain(callback?: MongoCallback<AggregationCursorResult>): void;
    geoNear(document: object): AggregationCursor<T>;
    group<U = T>(document: object): AggregationCursor<U>;
    hasNext(): Promise<boolean>;
    hasNext(callback: MongoCallback<boolean>): void;
    isClosed(): boolean;
    limit(value: number): AggregationCursor<T>;
    lookup(document: object): AggregationCursor<T>;
    match(document: object): AggregationCursor<T>;
    maxTimeMS(value: number): AggregationCursor<T>;
    next(): Promise<T | null>;
    next(callback: MongoCallback<T | null>): void;
    out(destination: string): AggregationCursor<T>;
    project<U = T>(document: object): AggregationCursor<U>;
    read(size: number): string | Buffer | void;
    redact(document: object): AggregationCursor<T>;
    rewind(): AggregationCursor<T>;
    skip(value: number): AggregationCursor<T>;
    sort(document: object): AggregationCursor<T>;
    toArray(): Promise<T[]>;
    toArray(callback: MongoCallback<T[]>): void;
    unshift(chunk: Buffer | string): void;
    unwind<U = T>(
        field: string | { path: string; includeArrayIndex?: string | undefined; preserveNullAndEmptyArrays?: boolean | undefined },
    ): AggregationCursor<U>;
}

export type CommandCursorResult = object | null;
export class CommandCursor extends Readable {
    batchSize(value: number): CommandCursor;
    clone(): CommandCursor;
    close(): Promise<CommandCursorResult>;
    close(callback: MongoCallback<CommandCursorResult>): void;
    each(callback: MongoCallback<CommandCursorResult>): void;
    hasNext(): Promise<boolean>;
    hasNext(callback: MongoCallback<boolean>): void;
    isClosed(): boolean;
    maxTimeMS(value: number): CommandCursor;
    next(): Promise<CommandCursorResult>;
    next(callback: MongoCallback<CommandCursorResult>): void;
    read(size: number): string | Buffer | void;
    rewind(): CommandCursor;
    setReadPreference(readPreference: ReadPreferenceOrMode): CommandCursor;
    toArray(): Promise<any[]>;
    toArray(callback: MongoCallback<any[]>): void;
    unshift(chunk: Buffer | string): void;
}

export class GridFSBucket extends EventEmitter {
    constructor(db: Db, options?: GridFSBucketOptions);
    delete(id: ObjectId, callback?: GridFSBucketErrorCallback): void;
    drop(callback?: GridFSBucketErrorCallback): void;
    find(filter: object, options?: GridFSBucketFindOptions): Cursor<any>;
    openDownloadStream(id: ObjectId, options?: { start: number; end: number }): GridFSBucketReadStream;
    openDownloadStreamByName(
        filename: string,
        options?: { revision: number; start: number; end: number },
    ): GridFSBucketReadStream;
    openUploadStream(filename: string, options?: GridFSBucketOpenUploadStreamOptions): GridFSBucketWriteStream;
    openUploadStreamWithId(
        id: GridFSBucketWriteStreamId,
        filename: string,
        options?: GridFSBucketOpenUploadStreamOptions,
    ): GridFSBucketWriteStream;
    rename(id: ObjectId, filename: string, callback?: GridFSBucketErrorCallback): void;
}

export interface GridFSBucketOptions {
    bucketName?: string | undefined;
    chunkSizeBytes?: number | undefined;
    writeConcern?: WriteConcern | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
}

export interface GridFSBucketErrorCallback extends MongoCallback<void> {}

export interface GridFSBucketFindOptions {
    batchSize?: number | undefined;
    limit?: number | undefined;
    maxTimeMS?: number | undefined;
    noCursorTimeout?: boolean | undefined;
    skip?: number | undefined;
    sort?: object | undefined;
}

export interface GridFSBucketOpenUploadStreamOptions {
    chunkSizeBytes?: number | undefined;
    metadata?: object | undefined;
    contentType?: string | undefined;
    aliases?: string[] | undefined;
}

export class GridFSBucketReadStream extends Readable {
    id: ObjectId;
    constructor(
        chunks: Collection<any>,
        files: Collection<any>,
        readPreference: object,
        filter: object,
        options?: GridFSBucketReadStreamOptions,
    );
}

export interface GridFSBucketReadStreamOptions {
    sort?: number | undefined;
    skip?: number | undefined;
    start?: number | undefined;
    end?: number | undefined;
}

export class GridFSBucketWriteStream extends Writable {
    id: GridFSBucketWriteStreamId;
    constructor(bucket: GridFSBucket, filename: string, options?: GridFSBucketWriteStreamOptions);
    abort(callback?: GridFSBucketErrorCallback): void;
}

export interface GridFSBucketWriteStreamOptions extends WriteConcern {
    id?: GridFSBucketWriteStreamId | undefined;
    chunkSizeBytes?: number | undefined;
    disableMD5?: boolean | undefined;
}

type EventArguments<T> = [T] extends [(...args: infer U) => any] ? U : [T] extends [undefined] ? [] : [T];

declare class TypedEventEmitter<Events> {
    addListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    on<E extends keyof Events>(event: E, listener: Events[E]): this;
    once<E extends keyof Events>(event: E, listener: Events[E]): this;
    prependListener<E extends keyof Events>(event: E, listener: Events[E]): this;
    prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this;

    off<E extends keyof Events>(event: E, listener: Events[E]): this;
    removeAllListeners<E extends keyof Events>(event?: E): this;
    removeListener<E extends keyof Events>(event: E, listener: Events[E]): this;

    emit<E extends keyof Events>(event: E, ...args: EventArguments<Events[E]>): boolean;
    eventNames(): Array<keyof Events>;
    rawListeners<E extends keyof Events>(event: E): Function[];
    listeners<E extends keyof Events>(event: E): Function[];
    listenerCount<E extends keyof Events>(event: E): number;

    getMaxListeners(): number;
    setMaxListeners(maxListeners: number): this;
}

interface ChangeStreamEvents<TSchema extends { [key: string]: any } = DefaultSchema> {
    change: (doc: ChangeEvent<TSchema>) => void;
    close: () => void;
    end: () => void;
    error: (err: MongoError) => void;
    resumeTokenChanged: (newToken: ResumeToken) => void;
}

export class ChangeStream<TSchema extends { [key: string]: any } = DefaultSchema> extends TypedEventEmitter<
    ChangeStreamEvents<TSchema>
> {
    resumeToken: ResumeToken;

    constructor(parent: MongoClient | Db | Collection, pipeline: object[], options?: ChangeStreamOptions);
    close(): Promise<any>;
    close(callback: MongoCallback<any>): void;
    hasNext(): Promise<any>;
    hasNext(callback: MongoCallback<any>): void;
    isClosed(): boolean;
    next(): Promise<any>;
    next(callback: MongoCallback<any>): void;
    stream(options?: { transform?: Function | undefined }): Cursor;
}

export class ResumeToken {}

export type ChangeEventTypes =
    | "insert"
    | "delete"
    | "replace"
    | "update"
    | "drop"
    | "rename"
    | "dropDatabase"
    | "invalidate";
export interface ChangeEventBase<TSchema extends { [key: string]: any } = DefaultSchema> {
    _id: ResumeToken;
    ns: {
        db: string;
        coll: string;
    };
    clusterTime: Timestamp;
    txnNumber?: number | undefined;
    lsid?: {
        id: any;
        uid: any;
    } | undefined;
}
export interface ChangeEventCR<TSchema extends { [key: string]: any } = DefaultSchema>
    extends ChangeEventBase<TSchema> {
    operationType: "insert" | "replace";
    fullDocument?: TSchema | undefined;
    documentKey: {
        _id: ExtractIdType<TSchema>;
    };
}
type FieldUpdates<TSchema> = Partial<TSchema> & { [key: string]: any };
export interface ChangeEventUpdate<TSchema extends { [key: string]: any } = DefaultSchema>
    extends ChangeEventBase<TSchema> {
    operationType: "update";
    updateDescription: {
        updatedFields: FieldUpdates<TSchema>;
        removedFields: Array<keyof TSchema | string>;
    };
    fullDocument?: TSchema | undefined;
    documentKey: {
        _id: ExtractIdType<TSchema>;
    };
}
export interface ChangeEventDelete<TSchema extends { [key: string]: any } = DefaultSchema>
    extends ChangeEventBase<TSchema> {
    operationType: "delete";
    documentKey: {
        _id: ExtractIdType<TSchema>;
    };
}
export interface ChangeEventRename<TSchema extends { [key: string]: any } = DefaultSchema>
    extends ChangeEventBase<TSchema> {
    operationType: "rename";
    to: {
        db: string;
        coll: string;
    };
}

export interface ChangeEventOther<TSchema extends { [key: string]: any } = DefaultSchema>
    extends ChangeEventBase<TSchema> {
    operationType: "drop" | "dropDatabase";
}

export interface ChangeEventInvalidate<TSchema extends { [key: string]: any } = DefaultSchema> {
    _id: ResumeToken;
    operationType: "invalidate";
    clusterTime: Timestamp;
}

export type ChangeEvent<TSchema extends object = { _id: ObjectId }> =
    | ChangeEventCR<TSchema>
    | ChangeEventUpdate<TSchema>
    | ChangeEventDelete<TSchema>
    | ChangeEventRename<TSchema>
    | ChangeEventOther<TSchema>
    | ChangeEventInvalidate<TSchema>;

export interface ChangeStreamOptions {
    fullDocument?: "default" | "updateLookup" | undefined;
    maxAwaitTimeMS?: number | undefined;
    resumeAfter?: ResumeToken | undefined;
    startAfter?: ResumeToken | undefined;
    startAtOperationTime?: Timestamp | undefined;
    batchSize?: number | undefined;
    collation?: CollationDocument | undefined;
    readPreference?: ReadPreferenceOrMode | undefined;
}

type GridFSBucketWriteStreamId = string | number | object | ObjectId;

export interface LoggerOptions {
    loggerLevel?: string | undefined;
    logger?: log | undefined;
}

export type log = (message?: string, state?: LoggerState) => void;

export interface LoggerState {
    type: string;
    message: string;
    className: string;
    pid: number;
    date: number;
}
export class Logger {
    constructor(className: string, options?: LoggerOptions);
    debug(message: string, object: LoggerState): void;
    error(message: string, object: LoggerState): void;
    info(message: string, object: LoggerState): void;
    isDebug(): boolean;
    isError(): boolean;
    isInfo(): boolean;
    isWarn(): boolean;
    static reset(): void;
    static currentLogger(): log;
    static setCurrentLogger(log: log): void;
    static filter(type: string, values: string[]): void;
    static setLevel(level: string): void;
}

export interface CollationDocument {
    locale: string;
    strength?: number | undefined;
    caseLevel?: boolean | undefined;
    caseFirst?: string | undefined;
    numericOrdering?: boolean | undefined;
    alternate?: string | undefined;
    maxVariable?: string | undefined;
    backwards?: boolean | undefined;
    normalization?: boolean | undefined;
}
export interface IndexSpecification {
    key: object;
    name?: string | undefined;
    background?: boolean | undefined;
    unique?: boolean | undefined;
    partialFilterExpression?: object | undefined;
    sparse?: boolean | undefined;
    expireAfterSeconds?: number | undefined;
    storageEngine?: object | undefined;
    weights?: object | undefined;
    default_language?: string | undefined;
    language_override?: string | undefined;
    textIndexVersion?: number | undefined;
    "2dsphereIndexVersion"?: number | undefined;
    bits?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
    bucketSize?: number | undefined;
    collation?: CollationDocument | undefined;
}
